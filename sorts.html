<!DOCTYPE html>
<html>
    <main>
        <head>
            <title>Sorts and Analysis</title>
            <link rel="stylesheet" href="main.css">
            <link rel="stylesheet" href="./fragments/main.css">
            <div id="navParent"></div>
            <script src="import.js"></script>
            <script src="main.js"></script>
            <script src="highlighter.js"></script>
            <script>
                importNav();
                highlighter();
            </script>
        </head>
        <div>
            <div id="toc" style="display:flex;float:left;width:21%;position:fixed;left:-13%;transition:0.2s ease-in-out;" onmouseenter="toggleTOC()" onmouseleave="toggleTOC()">
                <div id="toc-padding-left" style="padding:4%;"></div>
                <div id="toc-main" class="box rounded-corners">
                    <h3 id="toc-title" style="margin-left:5%;font-size:1.3vw;">Table of Contents</h3>
                    <p>
                        <ul id="toc-list" class="blue" style="font-size:1vw;">
                            <li><a class="blue blue-hover" href="#intro">Intro</a><br></li>
                            <li><a class="blue blue-hover" href="#limitations">Limitations</a></li>
                            <li><a class="blue blue-hover" href="#explanation">Explanation of Code</a></li>
                            <ul class="blue">
                                <li><a class="blue blue-hover" href="#selection">Selection Sort</a></li>
                                <li><a class="blue blue-hover" href="#merge">Merge Sort</a></li>
                                <li><a class="blue blue-hover" href="#bubble">Bubble Sort</a></li>
                            </ul>
                            <li><a class="blue blue-hover" href="#analysis" style="margin-right:0.7vw;">Analysis and Conclusion</a></li>
                        </ul>
                    </p>
                </div>
                <div id="toc-padding-right" style="padding:2%;"></div>
            </div>
            <script>
                let toc = document.getElementById("toc");
                function toggleTOC() {
                    toc.classList.toggle("toc-shown");
                }
            </script>
            <style>
                .toc-shown {
                    left: 0% !important;
                }
            </style>
            <section class="post">
                <h1 class="post-title">Sorts and Analysis</h1>
                <p class="caption" style="line-height:1.2">
                    Akhil Guntur - April 3, 2022<br>
                    <a class="blue blue-hover" href="https://replit.com/@algolg/akhil-t3" target="_blank">Replit Link</a>
                </p>
                <h1 id="intro">Intro</h1>
                <p class="box rounded-corners post-box">
                    Over the past week or so, I worked on implementing sorting algorithms on a data type of my own creation. 
                    In my case, this meant creating algorithms for <color class="red red-hover">selection</color>, 
                    <color class="red red-hover">bubble</color>, and <color class="red red-hover">merge</color> sorting algorithms, 
                    which I would run on a <color class="red red-hover">queue</color>, the class for which I made by myself. 
                    My hope is that my implementation will fulfull <color class="yellow yellow-hover">Objective #2</color>.
                </p>
                <h1 id="limitations">Limitations</h1>
                <p class="box rounded-corners post-box">
                    As I attempted to pursue Objective #2, there were some requirements which I wish to waive.<br>
                    My implementation of bubble sort was fairly complex (as I explain <a class="blue blue-hover" href="#bubble">later on</a>), 
                    and as a result, the performance of my algorithm was negatively affected. This made it hard for Java to process 
                    5000 elements of data for bubble sort. I tried doing so, and I have depicted my results below.
                </p>
                <div class="code-container">
                    <code>
<pre>Selection Sort:
Sorted in 180555506

^C<color class="code-highlight">%</color>

<color class="cyan">akhil-t3</color> on <color class="purple"> main</color> 
<color class="red">[⇡$!+]</color> took <color class="yellow">24m 30s</color></pre></code>
                </div>
                <p class="caption">
                    The program was set to run selection, then bubble, then merge sort.<br>
                    As shown, selection sort finished in ~0.18 sec.<br>
                    After over 24 minutes, bubble sort still wasn't done.
                </p>
                <p class="box rounded-corners post-box">
                    This is all to say that <color class="red red-hover">5000 terms was not doable</color> with my implementation, 
                    especially given how I planned on running each algorithm twelve times. 
                    And thus, I opted for a more humble <color class="red red-hover">500 terms</color>, which I found can still reveal how 
                    not all sorting algorithms are made equal.<br>
                    Other than that, I believe I incorporated all required elements of the assignment.
                </p>
                <h1 id="explanation">Explanation of Code</h1>
                <p class="box rounded-corners post-box">
                    Each sorting algorithm is a subclass of the Sort superclass. From this superclass, each algorithm inherits a 
                    Queue for storing times, a method to add times to the <color class="red red-hover">Queue</color>, a 
                    <color class="red red-hover">method</color> to average all times (removing the lowest and highest times), and a 
                    <color class="red red-hover">method</color> to make sure the sorted Queue really is sorted. Along with those, the 
                    Sort class contains the <code class="yellow">generateData()</pre></code> method, which fills the 
                    <color color="red">static</color> data Queue with <a class="blue blue-hover" href="#limitations">500</a> random ints. 
                    I made the data variable static to ensure that it was constant across all of the subclass sorting algorithms.
                </p>

                <h3 id="selection">Selection Sort</h3>
                <p class="box rounded-corners post-box">
                    Selection sort involves searching through a given data set, finding the term of least value 
                    (i.e. <color class="red red-hover">selecting</color> the smallest term), adding that value to a new data set, 
                    removing it from the original set, and repeating. Since Selection Sort frequently compares terms in a data set to 
                    a variable (the variable that contains the lowest int), Selection Sort features 
                    <color class="red red-hover">many comparisons</color>. However, terms are <color class="red red-hover">not swapped</color>.
                </p>
                <div class="code-container">
                    <code>
<pre>int lowest = Integer.<color class="blue">MAX_VALUE</color>;
<color class="red">for</color> (int i : data) {
    <color class="red">if</color> (i < lowest) {
        lowest = i;
    }
}</pre>
                    </code>
                </div>
                <p class="caption">
                    This chunk of code searches through <code class="blue">data</pre></code>, a Queue of Integers, and finds the lowest term.<br>
                </p>
                <p class="box rounded-corners post-box">
                    As one may expect, this algorithm does not scale very well. Until the set is fully sorted, the algorithm searches term-by-term 
                    through the entire set to find the lowest int.<br>
                    Since Selection Sort involves searching through the data set of length <color class="yellow yellow-hover">n</color> 
                    a total of <color class="yellow yellow-hover">n</color> times, this algorithm has a time complexity of 
                    <color class="yellow yellow-hover">O(n<sup>2</sup>)</color>.
                </p>
                <h3 id="merge">Merge Sort</h3>
                <p class="box rounded-corners post-box">
                    By contrast, the merge sort is a relatively efficient sorting algorithm. It involves splitting a given data set in halves 
                    until single-element sets are formed. Single-element sets of a common parent are compared with each other and sorted. 
                    These sets are then <color class="red red-hover">merged</color> back together to form a complete, sorted set. 
                    Since Merge Sort makes comparisons and swaps at the lowest level, this algorithm features 
                    <color class="yellow yellow-hover">few comparisons and swaps</color>.
                </p>
            </section>
            <div class="code-section">
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
<pre>int sta = 0;
int mid = data.<color class="purple">size</color>()/<color class="blue">2</color>;
int end = data.<color class="purple">size</color>();

int halfOne = mid - sta;
int halfTwo = end - mid;</pre>
                        </code>
                    </div>
                    <p class="caption">
                        Variables are initialized. These will be used to split the data set into multiple sets.
                    </p>
                </div>
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
<pre>Queue&lt;Integer&gt; qOne = <color class="red">new</color> Queue<>();
Queue&lt;Integer&gt; qTwo = <color class="red">new</color> Queue<>();

<color class="red"r>for</color> (int i=<color class="blue">0</color>; i&lt;halfTwo; i++) {
    qTwo.<color class="purple">enqueue</color>(data.<color class="purple">peek</color>());
    if (data.<color class="purple">size</color>()><color class="blue">0</color>) {
        data.<color class="purple">dequeue</color>();
    }
}
<color class="red"r>for</color> (int i=<color class="blue">0</color>; i&lt;halfOne; i++) {
    qTwo.<color class="purple">enqueue</color>(data.<color class="purple">peek</color>());
    if (data.<color class="purple">size</color>()><color class="blue">0</color>) {
        data.<color class="purple">dequeue</color>();
    }
}</pre>
                        </code>
                    </div>
                    <p class="caption" style="width:90%;">
                        Queues are initialized. The original data set is split into two sets.
                    </p>
                </div>
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
<pre><color class="red">if</color> (qOne.<color class="purple">size</color>()><color class="blue">1</color>) {
    qOne = <color class="purple">Sort</color>(qOne);
}
<color class="red">if</color> (qTwo.<color class="purple">size</color>()><color class="blue">1</color>) {
    qTwo = <color class="purple">Sort</color>(qTwo);
}</pre>
                        </code>
                    </div>
                    <p class="caption">
                        These Queues are then split further until they only contain one element
                    </p>
                </div>
            </div>
            <section class="post">
                <p class="box rounded-corners post-box">
                    Since Merge Sort's algorithm involves halving a given data set many times, this algorithm has a time complexity of 
                    <color class="yellow yellow-hover">O(n log(n))</i></color>.
                </p>
                <h3 id="bubble">Bubble Sort</h3>
                <p class="box rounded-corners post-box">
                    Bubble Sort was by far the least efficient algorithm I tested, as illustrated by the issues I detailed 
                    <a class="blue blue-hover" href="#limitations">earlier</a>. I challenged myself to implement the algorithm only using 
                    classes I made, and I ended up having to use both <color class="yellow yellow-hover">Queues</color> and 
                    <color class="yellow yellow-hover">Stacks</color> to successfully accomplish this task. The Bubble Sort algorithm involves 
                    comparing consecutive elements and swapping if necessary. Thus, Bubble Sort makes 
                    <color class="yellow yellow-hover">many comparisons and swaps</color>. 
                    <color class="red red-hover">I do not know why it is called Bubble Sort</color>.
                </p>
            </section>
            <div class="code-section">
                <div style="margin:auto;width:25%;">
                   <div class="code-container">
                       <code>
<pre>Queue&lt;Integer&gt; temp = <color class="red">new</color> <br>Queue<>();
Stack&lt;Integer&gt; newData = <color class="red">new</color> <br>Stack<>();
Queue&lt;Integer&gt; newDataQ = <color class="red">new</color> <br>Queue<>();</pre>
                        </code>
                    </div>
                    <p class="caption" style="width:100%;">
                            Queues and Stacks are initialized. The data Queue will first be sorted into a Stack, and converted into a Queue at the end.
                    </p>
                </div>
                <div style="margin:auto;width:25%;">
                    <div class="code-container">
                        <code>
<pre>boolean found = <color class="blue">false</color>;
int previous = <color class="blue">-1</color>;
<color class="red">for</color> (int i : data) {
    <color class="red">if</color> (!found) {
        newData.<color class="purple">push</color>(i);
    }
    <color class="red">else</color> {
        temp.<color class="purple">enqueue</color>(i);
    }
    <color class="red">if</color> (i < previous) {
        found = <color class="blue">true</color>;
    }
    previous = i;
}</pre>
                        </code>
                    </div>
                    <p class="caption" style="width:100%">
                        The data set is parsed for anomolies (where an int is smaller than the previous int). 
                        Until one is found, terms are added to a Stack. Afterwards, terms are added to a Queue.
                    </p>
                </div>
                <div style="margin:auto;width:25%;">
                    <div class="code-container">
                        <code>
<pre>int smaller = newData.<color class="purple">peek</color>();
newData.<color class="purple">pop</color>();
int bigger = newData.<color class="purple">peek</color>();
newData.<color class="purple">pop</color>();
newData.<color class="purple">push</color>(smaller);
newData.<color class="purple">push</color>(bigger);

<color class="red">while</color> (temp.size()>0) {
    newData.<color class="purple">push</color>(temp.<color class="purple">peek</color>());
    temp.dequeue();
}<br></pre>
                        </code>
                    </div>
                    <p class="caption" style="width:100%;">
                        Since the top element of the stack is smaller than the element that precedes it, we switch the two. Then, we add the remaining elements, which were stored in the newData Queue.
                    </p>
                </div>
            </div>
            <section class="post">
               <p class="box rounded-corners post-box">
                    Bubble Sort involves reading all terms of a given data set, and in addition to that, it is a 
                    <color class="red red-hover">recursive</color> algorithm. Thus, Bubble Sort has a time complexity of 
                    <color class="yellow yellow-hover">O(n<sup>2</sup>)</color>.
                </p> 
                <h1 id="analysis">Analysis and Conclusion</h1>
                <p class="box rounded-corners post-box">
                    Upon running the main tester method of the Sort class, twelve tests of each sorting algorithm will be executed and 
                    times are collected, following which the highest and lowest times of each sorting algorithm are removed, and 
                    times are averaged. Average times of one test run are shown below.
                </p>
                <div class="code-container">
                    <code>
<pre>AVERAGES (EXCL. MAX AND MIN)
Selection Sort: 1919297 ns
Bubble Sort:    1031338857 ns
Merge Sort:     412588 ns</pre>
                    </code>
                </div>
                <p class="box rounded-corners post-box">
                    As shown, Merge Sort has the lowest time, and Bubble Sort by far has the highest time. <br><br>
                    As previously discussed, Merge Sort is the only algorithm with a time complexity of O(n), with the other 
                    two algorithms having a time complexity of O(n<sup>2</sup>). <br><br>
                    Furthermore, the Merge Sort algorithm features few comparisons and few swaps, while the other two algorithms frequently 
                    do one or both. <br><br>
                    It is thus safe to conclude that <color class="red red-hover">Merge Sort is the most efficient</color> of the 
                    algorithms tested, and <color class="red red-hover">Bubble Sort is the least</color>.
                </p>
                <p class="box rounded-corners post-box footer">
                    — <a class="blue blue-hover" href="https://github.com/algolg" target="_blank">@algolg</a>
                </p>
            </section>
        </div>
    </main>
</html>
