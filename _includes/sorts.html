<!--<!DOCTYPE html>-->
<html>
    <main>
        <head>
            <title>Sorts and Analysis</title>
<!--            <link rel="stylesheet" href="main.css">-->
<!--            <link rel="stylesheet" href="../../fragments/main.css">-->
<!--            <div id="navParent"></div>-->
<!--            <script src="../assets/js/import.js"></script>-->
<!--            <script src="../assets/js/main.js"></script>-->
<!--            <script src="../assets/js/highlighter.js"></script>-->
<!--            <script>-->
<!--                importNav();-->
<!--                highlighter();-->
<!--            </script>-->
        <script>
            highlighter();
        </script>
        </head>
        <div>
            <div id="toc" style="display:flex;float:left;width:21%;position:fixed;left:-13%;transition:0.2s ease-in-out;" onmouseenter="toggleTOC()" onmouseleave="toggleTOC()">
                <div id="toc-padding-left" style="padding:4%;"></div>
                <div id="toc-main" class="box rounded-corners">
                    <h3 id="toc-title" style="margin-left:5%;font-size:1.3vw;">Table of Contents</h3>
                    <p>
                        <ul id="toc-list" class="blue" style="font-size:1vw;">
                            <li><a class="blue blue-hover" href="#intro">Intro</a><br></li>
                            <li><a class="blue blue-hover" href="#challenges">Challenges</a></li>
                            <li><a class="blue blue-hover" href="#explanation">Explanation of Code</a></li>
                            <ul class="blue">
                                <li><a class="blue blue-hover" href="#selection">Selection Sort</a></li>
                                <li><a class="blue blue-hover" href="#merge">Merge Sort</a></li>
                                <li><a class="blue blue-hover" href="#bubble">Bubble Sort</a></li>
                            </ul>
                            <li><a class="blue blue-hover" href="#analysis" style="margin-right:0.7vw;">Analysis and Conclusion</a></li>
                        </ul>
                    </p>
                </div>
                <div id="toc-padding-right" style="padding:2%;"></div>
            </div>
            <script>
                let toc = document.getElementById("toc");
                function toggleTOC() {
                    toc.classList.toggle("toc-shown");
                }
            </script>
            <style>
                .toc-shown {
                    left: 0% !important;
                }
            </style>
            <section class="post">
                <h1 class="post-title">Sorts and Analysis</h1>
                <p class="caption" style="line-height:1.2">
                    Akhil Guntur - April 3, 2022<br>
                    <a class="blue blue-hover" href="https://replit.com/@algolg/akhil-t3" target="_blank">Replit Link</a>
                </p>
                <h1 id="intro">Intro</h1>
                <p class="box rounded-corners post-box">
                    Over the past week or so, I worked on implementing sorting algorithms on a data type of my own creation. 
                    In my case, this meant creating algorithms for <color class="red red-hover">selection</color>, 
                    <color class="red red-hover">bubble</color>, and <color class="red red-hover">merge</color> sorting algorithms, 
                    which I would run on a <color class="red red-hover">queue</color>, the class for which I made by myself. 
                    My hope is that my implementation will fulfull <color class="yellow yellow-hover">Objective #2</color>.
                </p>
                <div>
                    <h1 id="challenges">Challenges</h1>
                    <p class="box rounded-corners post-box">
                        As I attempted to pursue Objective #2, there were some issues I ran into.<br>
                        My old implementation of Bubble Sort was fairly complex, 
                        and as a result, the performance of my algorithm was negatively affected. This made it hard for Java to process 
                        5000 elements of data for bubble sort. I tried doing so, and I have depicted my results below.
                    </p>
                    <div class="code-container">
                        <code>
                            <pre>
<!--                        -->Selection Sort:
<!--                        -->Sorted in 180555506
<!--                        -->
<!--                        -->^C<color class="code-highlight">%</color>
<!--                        -->
<!--                        --><color class="cyan">akhil-t3</color> on <color class="purple"> main</color> 
<!--                        --><color class="red">[⇡$!+]</color> took <color class="yellow">24m 30s</color></pre>
                            </code>
                    </div>
                    <p class="caption">
                        The program was set to run selection, then bubble, then merge sort.<br>
                        As shown, selection sort finished in ~0.18 sec.<br>
                        After over 24 minutes, bubble sort still wasn't done.
                    </p>
                    <p class="box rounded-corners post-box">
                        This is all to say that <color class="red red-hover">5000 terms was not doable</color> with my old implementation, 
                        and thus, I opted for a more humble <color class="red red-hover">500 terms</color>, which I found can still reveal how 
                        not all sorting algorithms are made equal.<br>
                        Eventually, I realized that the root of my problem was a lack of a proper swap method; after implementing this, my 
                        code was saved.
                    </p>
                </div>
                <h1 id="explanation">Explanation of Code</h1>
                <p class="box rounded-corners post-box">
                    Each sorting algorithm is a subclass of the Sort superclass. From this superclass, each algorithm inherits a 
                    Queue for storing times, a method to add times to the <color class="red red-hover">Queue</color>, a 
                    <color class="red red-hover">method</color> to average all times (removing the lowest and highest times), and a 
                    <color class="red red-hover">method</color> to make sure the sorted Queue really is sorted. Along with those, the 
                    Sort class contains the <code class="yellow">generateData()</pre></code> method, which fills the 
                    <color color="red">static</color> data Queue with <a class="blue blue-hover" href="#limitations">500</a> random ints. 
                    I made the data variable static to ensure that it was constant across all of the subclass sorting algorithms.
                </p>

                <h3 id="selection">Selection Sort</h3>
                <p class="box rounded-corners post-box">
                    Selection sort involves searching through a given data set, finding the term of least value 
                    (i.e. <color class="red red-hover">selecting</color> the smallest term), adding that value to a new data set, 
                    removing it from the original set, and repeating. Since Selection Sort frequently compares terms in a data set to 
                    a variable (the variable that contains the lowest int), Selection Sort features 
                    <color class="red red-hover">many comparisons</color>. However, terms are <color class="red red-hover">not swapped</color>.
                </p>
                <div class="code-container">
                    <code>
                        <pre>
<!--                    -->int lowest = Integer.MAX_VALUE;
<!--                    -->for (int i : data) {
<!--                    -->    if (i < lowest) {
<!--                    -->        lowest = i;
<!--                    -->    }
<!--                    -->}</pre>
                    </code>
                </div>
                <p class="caption">
                    This chunk of code searches through <code class="blue">data</code>, a Queue of Integers, and finds the lowest term.<br>
                </p>
                <p class="box rounded-corners post-box">
                    As one may expect, this algorithm does not scale very well. Until the set is fully sorted, the algorithm searches term-by-term 
                    through the entire set to find the lowest int.<br>
                    Since Selection Sort involves searching through the data set of length <color class="yellow yellow-hover">n</color> 
                    a total of <color class="yellow yellow-hover">n</color> times, this algorithm has a time complexity of 
                    <color class="yellow yellow-hover">O(n<sup>2</sup>)</color>.
                </p>
                <h3 id="merge">Merge Sort</h3>
                <p class="box rounded-corners post-box">
                    By contrast, the merge sort is a relatively efficient sorting algorithm. It involves splitting a given data set in halves 
                    until single-element sets are formed. Single-element sets of a common parent are compared with each other and sorted. 
                    These sets are then <color class="red red-hover">merged</color> back together to form a complete, sorted set. 
                    Since Merge Sort makes comparisons and swaps at the lowest level, this algorithm features 
                    <color class="yellow yellow-hover">few comparisons and swaps</color>.
                </p>
            </section>
            <div class="code-section">
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
                            <pre>
<!--                        -->Node&lt;Integer&gt; i;
<!--                        -->Queue&lt;Integer&gt; qOne = new Queue<>();
<!--                        -->Queue&lt;Integer&gt; qTwo = new Queue<>();
<!--                        -->
<!--                        -->i = data.tail;
<!--                        -->for (int j=0; j<(data.size())/2; j++) {
<!--                        -->    qTwo.enqueue(i.data);
<!--                        -->    i = i.next;
<!--                        -->}
<!--                        -->while (i != null) {
<!--                        -->    qOne.enqueue(i.data);
<!--                        -->    i = i.next;
<!--                        -->}</pre>
                        </code>
                    </div>
                    <p class="caption" style="width:90%;">
                        Queues are initialized. The original data set is split into two sets.
                    </p>
                </div>
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
                            <pre>
<!--                        -->if (qOne.size()>1) {
<!--                        -->    qOne = Sort(qOne);
<!--                        -->}
<!--                        -->if (qTwo.size()>1) {
<!--                        -->    qTwo = Sort(qTwo);
<!--                        -->}</pre>
                        </code>
                    </div>
                    <p class="caption">
                        These Queues are then split further until they only contain one element
                    </p>
                </div>
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
                            <pre>sorted = Queue.merge(qOne, qTwo);</pre>
                        </code>
                    </div>
                    <p class="caption">
                        Queue class's "merge" method is run, which compares items in each Queue and merges them in order
                    </p>
                </div>
            </div>
            <section class="post">
                <p class="box rounded-corners post-box">
                    Since Merge Sort's algorithm involves halving a given data set many times, this algorithm has a time complexity of 
                    <color class="yellow yellow-hover">O(n log(n))</i></color>.
                </p>
                <h3 id="bubble">Bubble Sort</h3>
                <p class="box rounded-corners post-box">
                    Bubble Sort was by far the least efficient algorithm I tested, as illustrated by the issues I detailed 
                    <a class="blue blue-hover" href="#limitations">earlier</a>. I challenged myself to implement the algorithm only using 
                    classes I made, and I ended up having to use both <color class="yellow yellow-hover">Queues</color> and 
                    <color class="yellow yellow-hover">Stacks</color> to successfully accomplish this task. The Bubble Sort algorithm involves 
                    comparing consecutive elements and swapping if necessary. Thus, Bubble Sort makes 
                    <color class="yellow yellow-hover">many comparisons and swaps</color>. 
                    <color class="red red-hover">I do not know why it is called Bubble Sort</color>.
                </p>
            </section>
            <div class="code-section">
                <div style="margin:auto;width:25%;">
                   <div class="code-container">
                       <code>
                           <pre>
<!--                        -->Queue&lt;Integer&gt; temp = new Queue<>();
<!--                        -->Stack&lt;Integer&gt; newData = new Stack<>();
<!--                        -->Queue&lt;Integer&gt; newDataQ = new Queue<>();</pre>
                        </code>
                    </div>
                    <p class="caption" style="width:100%;">
                            Queues and Stacks are initialized. The data Queue will first be sorted into a Stack, and converted into a Queue at the end.
                    </p>
                </div>
                <div style="margin:auto;width:25%;">
                    <div class="code-container">
                        <code>
                            <pre>
<!--                        -->boolean found = false;
<!--                        -->int previous = -1;
<!--                        -->for (int i : data) {
<!--                        -->    if (!found) {
<!--                        -->        newData.push(i);
<!--                        -->    }
<!--                        -->    else {
<!--                        -->        temp.enqueue(i);
<!--                        -->    }
<!--                        -->    if (i < previous) {
<!--                        -->        found = true;
<!--                        -->    }
<!--                        -->    previous = i;
<!--                        -->}</pre>
                        </code>
                    </div>
                    <p class="caption" style="width:100%">
                        The data set is parsed for anomolies (where an int is smaller than the previous int). 
                        Until one is found, terms are added to a Stack. Afterwards, terms are added to a Queue.
                    </p>
                </div>
                <div style="margin:auto;width:25%;">
                    <div class="code-container">
                        <code>
                            <pre>
<!--                        -->int smaller = newData.peek();
<!--                        -->newData.pop();
<!--                        -->int bigger = newData.peek();
<!--                        -->newData.pop();
<!--                        -->newData.push(smaller);
<!--                        -->newData.push(bigger);
<!--                        -->
<!--                        -->while (temp.size()>0) {
<!--                        -->    newData.push(temp.peek());
<!--                        -->    temp.dequeue();
<!--                        -->}</pre>
                        </code>
                    </div>
                    <p class="caption" style="width:100%;">
                        Since the top element of the stack is smaller than the element that precedes it, we switch the two. Then, we add the remaining elements, which were stored in the newData Queue.
                    </p>
                </div>
            </div>
            <section class="post">
               <p class="box rounded-corners post-box">
                    Bubble Sort involves reading all terms of a given data set, and in addition to that, it is a 
                    <color class="red red-hover">recursive</color> algorithm. Thus, Bubble Sort has a time complexity of 
                    <color class="yellow yellow-hover">O(n<sup>2</sup>)</color>.
                </p> 
                <h1 id="analysis">Analysis and Conclusion</h1>
                <p class="box rounded-corners post-box">
                    Upon running the "main" tester method of the "Sort" class, 5000 total tests are run for each sorting algorithm: 
                    for each of 500 random data sets, ranging in length from 100 to 5000 by increments of 10, ten tests are run. After each 
                    iteration, times, the number of swaps, and the number of comparisons are collected in CSV files. The graphs depicting 
                    these CSV files are shown below.
                </p>
                <div style="overflow:hidden;">
                    <img id="graphs-carousel" index="0" style="width:100%;scale:1.005;" src="assets/time.svg">
                    <div style="display:flex;">
                        <button class="centered-svg-container" style="width:50%;margin-right:2px;" onclick="nextGraph('backward');">
                            <div class="centered-svg">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" style="margin:10px;" fill="currentColor" class="bi bi-arrow-left" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/>
                                </svg>
                            </div>
                        </button>
                        <button class="centered-svg-container" style="width:50%;margin-left:2px;" onclick="nextGraph('forward');">
                            <div class="centered-svg">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" style="margin:10px;" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/>
                                </svg>
                            </div>
                        </button>
                    </div>
                    <script>
                        graphs = ["assets/time.svg", "assets/swaps.svg", "assets/comparisons.svg"];
                        graphs_carousel = document.getElementById("graphs-carousel");
                        function nextGraph(direction) {
                            idx = graphs_carousel.getAttribute("index");
                            switch (direction) {
                                case "backward":
                                    console.log((idx-1)%graphs.length);
                                    graphs_carousel.setAttribute("src", graphs[mod(idx-1, graphs.length)]);
                                    graphs_carousel.setAttribute("index", mod(idx-1, graphs.length));
                                    break;
                                case "forward":
                                    graphs_carousel.setAttribute("src", graphs[mod(idx+1, graphs.length)]);
                                    graphs_carousel.setAttribute("index", mod(idx+1, graphs.length));
                                    break;
                            }
                        }
                        function mod(a, b) {
                            return ((a%b)+b)%b;
                        }
                    </script>
                </div>
                <p class="box rounded-corners post-box">
                    As shown, Merge Sort by far takes the lowest time to complete, and Selection Sort has the highest time. <br><br>
                    As previously discussed, Merge Sort is the only algorithm with a time complexity of O(n), with the other 
                    two algorithms having a time complexity of O(n<sup>2</sup>). This trend is also shown in the graphs, where it 
                    can be seen that Merge Sort tapers flatlines, similar to a logarithmic graph and unlike the other two graphs. <br><br>
                    Furthermore, the Merge Sort algorithm features few comparisons and few swaps, while the other two algorithms frequently 
                    do one or both. <br><br>
                    It is thus safe to conclude that <color class="red red-hover">Merge Sort is the most efficient</color> of the 
                    algorithms tested.
                </p>
                <p class="box rounded-corners post-box footer">
                    — <a class="blue blue-hover" href="https://github.com/algolg" target="_blank">@algolg</a>
                </p>
            </section>
        </div>
    </main>
</html>
